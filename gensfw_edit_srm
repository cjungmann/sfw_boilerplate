#!/bin/bash

declare -a SRMLINES
declare -i SRMLINES_COUNT

declare RE_SRM_LINE='^([[:space:]]*)([^[:space:]#].*)[#[:space:]]*.*$'
declare RE_STRING_TRIM='^[[:space:]]*(.*[^[:space:]])[[:space:]]*$'
declare RE_NODE_TEST="^(([^:\[]+)(:[^[:space:]\[]+)?)(\[.*)?"

# The first functions return no data (no echo to stdout (1)),
# but return 0 or 1 to be suitable for use with a conditional
# statement:
#    in_range
#    is_srm_comment
#    is_srm
#    matches_predicate
#    matches_step

in_range() { local -i ndx="$1"; [ "$ndx" -lt "${SRMLINES_COUNT}" -a "$ndx" -ge 0 ]; }
is_srm_comment() { [[ "$1" =~ $\\s*# ]]; }
is_srm()
{
    local path="$1"
    local ext=
    local IFS=$'.'
    local -a pathparts
    local -i partcount
    if [ -f "$path" ]; then
        pathparts=( $( echo "$path" ) )
        partcount="${#pathparts[@]}"
        if [ $partcount -gt 1 ]; then
            ext="${pathparts[ $(( partcount-1)) ]}"
            if [ "$ext" = "srm" ]; then
                return 0
            fi
        fi
    fi
    return 1
}

# Checks for and, if found, evaluates the predicate part of
# a search step.  That is, the expressions enclosed in square
# braces following a node_test, ie 'edit/schema/field[readOnly]'
#
# This function initiates recursion to validate the predicate
# expressions, which may also contain predicates.  However,
# this function never produces output, but should only be used
# as a conditional statement to identify a matching line.
matches_predicate()
{
    if [ -z "$1" ]; then
        return 0
    fi

    local predicate="$1"

    local -i matched_line="$2"

    local -i predlen="${#predicate}"
    local -a pchars
    local cchar
    local -i nesting=0
    local IFS=''

    local expression
    local -a expressions

    has_chars() { [ "${#pchars[@]}" -gt 0 ]; }

    # Collect predicate expressions from predicate:
    local -i index=-1
    local -i brace=1
    while [ "$(( ++index ))" -lt "${predlen}" ]; do
        cchar="${predicate:$index:1}"
        brace=1
        case "$cchar" in
            \[) (( ++nesting )); brace=0 ;;
            \]) (( --nesting )); brace=0 ;;
        esac

        if [ $brace -eq 0 ]; then
            if has_chars; then
                if [ $nesting -eq 0  ] && has_chars; then
                    expressions+=( $( echo "${pchars[*]}" ) )
                    pchars=
                elif [ $nesting -lt 0 ] && has_chars; then
                    break
                fi
            fi
        else
            pchars+=( "$cchar" )
        fi

    done

    if [ $nesting -ne 0 ]; then
        echo "ERROR: mismatched square braces" >&2
        return 1
    fi

    local -i ignored_line_number
    for expression in "${expressions[@]}"; do
        ignored_line_number=$( find_srm_line "$expression" "$matched_line" )
        if [ $? -ne 0 ]; then
            return 1
        fi
    done

    return 0
}

# This function parses the step into the node_test and optional
# predicate expressions.  It validates the node_test, then
# delegates predicate processing to matches_predicate().
#
# A conditional function, it produces no output and is to be
# used in a conditional statement like:
# if matches_step "$step" "$line" "$index_of_line"; then
#    .
# fi
matches_step()
{
    local IFS OIFS="${IFS}"

    # Argument #1, search path 'step'
    # Break the step into a node_test and zero-or-more predicates:
    local step="$1"
    local -a node_test
    local predicate

    if [[ "$step" =~ $RE_NODE_TEST ]]; then
        IFS=$':'
        node_test=( $( echo "${BASH_REMATCH[1]}" ) )
        predicate="${BASH_REMATCH[4]}"
    fi

    # Argument #2, trimmed instruction line.
    # Break into parts for comparison to current line:
    local iline="$2"
    local -a line_parts
    IFS=$':'
    line_parts=( $( echo "$iline" ) )

    local val
    local tag=$( trim_string "${line_parts[0]}" )
    if [ "${#line_parts[@]}" -gt 1 ]; then
        # Val may include colons, so repack remaining array:
        val="${line_parts[@]:1}"
        val=$( trim_string "${val[*]}" )
    fi

    # Argument #3
    local -i srmline="$3"

    tag_matches() { [ "$tag" = "${node_test[0]}" ]; }
    val_matches() { [ "${#node_test[@]}" -lt 2 -o "$val" = "${node_test[1]}" ]; }

    if tag_matches && val_matches; then
        if matches_predicate "$predicate" $"srmline"; then
            return 0
        fi
    fi

    return 1
}

# Remove leading and trailing spaces from text in $1
trim_string()
{
    if [[ "$1" =~ $RE_STRING_TRIM ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo "$1"
    fi
}

make_spaces()
{
    local -i i
    for i in `seq 1 $1`; do
        printf ' '
    done
}

find_in_array()
{
    local needle="$1"
    local straw
    local -i ndx=0
    for straw in "${@:2}"; do
        if [ "$straw" = "$needle" ]; then
            echo "$ndx"
            return 0
        fi
        (( ++ndx))
    done
    return 1
}


# Returns the count of leading white-space characters
# in a text string.  This value represents the 'level.'
# 
# This also serves as a conditional function.  A non-SRM
# line will return false (1).
line_level()
{
    if [[ "$1" =~ $RE_SRM_LINE ]]; then
        echo "${#BASH_REMATCH[1]}"
        return 0
    else
        return 1
    fi
}

srm_level()
{
    local -i index="$1"
    if in_range "$index"; then
        line_level "${SRMLINES[$index]}"
    else
        echo "Index $index is out-of-range for list of $SRMLINES_COUNT lines." >&2
        return 1
    fi
}

# Returns the level of the first child line, that is
# the first non-comment line whose level (as determined
# by srm_level()) is greater than the line from which
# the search began.
#
# The returned value is then used to filter a line
# search to ignore second or later generation offspring
# and to terminate a lines scan.
#
# This function returns 1 if no child is found, so it
# can be used as a conditional statement as well as for
# its output.
get_child_level()
{
    local -i index="$1"
    local -i level
    local -i stop_level=$( srm_level "$start" )
    while in_range "$(( ++index ))"; do
        if [[ "${SRMLINES[$index]}" =~ $RE_SRM_LINE ]]; then
            level="${#BASH_REMATCH[1]}"
            if [ "$level" -le "$stop_level" ]; then
                return 1
            elif [ "$level" -gt "$stop_level" ]; then
                echo "$level"
                return 0
            fi
        fi
    done

    return 1
}


# Given a path 'step' and a starting line, this function
# returns the index number (into SRMLINES array) of the
# FIRST ONLY line that matches the 'step'.
#
# This function returns 1 if no line is found, so it can
# be used as a conditional statement as well as for its
# output.
find_srm_line()
{
    local step="$1"
    local -i start="$2"

    # First step needs target_level=0 to find mode lines,
    # Otherwise, the target_level is the level of the
    # first child under the starting line:
    local -i terminate_level=-1
    local -i target_level=0
    if [ "$start" -ge 0 ]; then
        terminate_level=$( srm_level "$start" )
        target_level=$( get_child_level "$start" )
    fi

    local line spaces instruction

    local -i level
    local -i index="$start"
    while in_range "$(( ++index ))"; do
        if [[ "${SRMLINES[$index]}" =~ $RE_SRM_LINE ]]; then
            level="${#BASH_REMATCH[1]}"
            if [ "$level" -eq "$target_level" ]; then
                if matches_step "$step" "${BASH_REMATCH[2]}" "${index}"; then
                    echo "$index"
                    return 0
                fi
            elif [ "$level" -le "$terminate_level" ]; then
                return 1
            elif [ "$level" -gt "$target_level" ]; then
                continue
            fi
        fi
    done
    return 1
}

get_child_indices()
{
    local -i index="$1"
    local -i clevel plevel tlevel

    plevel=$( srm_level "$index" )

    while in_range $(( ++index )); do
        if tlevel=$( srm_level "$index" ); then
            if [ "$tlevel" -gt "$plevel" ]; then
                if [ -z "$clevel" ]; then
                    clevel="$tlevel"
                    echo "$index"
                elif [ "$tlevel" -eq "$clevel" ]; then
                    echo "$index"
                elif [ "$tlevel" -lt "$clevel" ]; then
                    # There should not be any levels
                    # between the child and the parent.
                    echo "Levels messed up." >&2
                fi
            else
                break
            fi
        fi
    done

    [ -n "$clevel" ]
}

# Prints a branch and its offspring, using recursion
# to produce indenting.
print_branch()
{
    local -i index="$1"
    local -i indent="${2:-0}"

    local spaces=$( make_spaces $indent )

    local line="${SRMLINES[$index]}"

    if [[ "$line" =~ $RE_SRM_LINE ]]; then
        # print current line,
        local instruction="${BASH_REMATCH[2]}"
        echo "${spaces}$instruction"

        carray=( $( get_child_indices "$index" ) )

        local -i cindex
        for cindex in "${carray[@]}"; do
            print_branch "$cindex" $(( indent+3 ))
        done
    else
        echo -n "'$spaces'"
        trim_string "$line"
    fi
}

print_srm()
{
    local -i index=-1
    local -i level
    local line
    while in_range $(( ++index )); do
        line="${SRMLINES[$index]}"
        level=$( line_level "$line" )
        if [ $? -eq 0 ]; then
            if [ "$level" -eq 0 ]; then
                print_branch "$index"
            fi
        else
            # If not an SRM line, it is a comment or empty line,
            # which will be preserved in the output file:
            echo "$line"
        fi
    done
}

# This function searches the entire SRMLINES array to find
# the SRMLINES line index that satisfies the 'path' value.
find_branch()
{
    local path="$1"
    local -i starting_srm_line="${2:--1}"
    local -i found_srm_line

    local -a pparts
    local IFS='/'
    pparts=( $( echo "$path" ) )
    local step="${pparts[0]}"

    found_srm_line=$( find_srm_line "$step" $starting_srm_line )
    if [ $? -eq 0 ]; then
        if [ $found_srm_line -ge 0 ]; then
            if [ "${#pparts[@]}" -gt 1 ]; then
                local -a subarr="${pparts[@]:1}"
                find_branch "${subarr[*]}" $found_srm_line
            else
                echo $found_srm_line
            fi
        fi
    fi
}

# When appending content after a branch, it must go
# after the last element in the branch.  This function
# finds the line after which an append can be placed.
find_branch_last_line()
{
    local -i index="$1"

    if ! in_range "$index"; then
        echo "Index '$index' out-of range in find_branch_last_line" >&2
        return 1
    elif [ "$index" -eq $(( SRMLINES_COUNT - 1 )) ]; then
        # last line of file is last line of branch
        echo "$index"
        return 0
    fi

    local -i ref_level=$( srm_level "$index" )
    local -i off_level

    while in_range $(( ++index )); do
        off_level=$( srm_level "$index" )
        if [ "$off_level" -ge "$ref_level" ]; then
            break
        fi
    done
    
    if [ -n "$off_level" ]; then
        (( --index ))
    fi

    echo "$index"
    return 0
}

read_srm_file()
{
    local filepath="$1"
    local line

    # IFS required to preserve leading spaces
    local IFS=$'\n'

    if [ -f "$filepath" ]; then
        while read -s line; do
            SRMLINES+=( "$line" )
        done  < "$filepath"

        SRMLINES_COUNT="${#SRMLINES[@]}"
        return 0
    fi

    return 1
}

SRM_splice()
{
    local -i index="$1"
    local -i remove="$2"
    local line

    local IFS=$'\n'

    if in_range "$index"; then
        local -i start_right=0

        # Left side, if any:
        if [ "$index" -gt 0 ]; then
            for line in "${SRMLINES[@]:0:$index}"; do
                echo "$line"
            done
            # echo "${SRMLINES[*]:0:$(( index ))}"
            start_right="$index"
        fi

        # New elements, if any
        local spaces=$( make_spaces $( srm_level "$index" ) )
        local param
        for param in "${@:3}"; do
            echo "${spaces}$param"
        done

        # Right side, if any left
        if [ "$remove" -gt 0 ]; then
            (( start_right += "$remove" ))
        fi

        if in_range "$start_right"; then
            for line in "${SRMLINES[@]:$start_right}"; do
                echo "$line"
            done
            # echo "${SRMLINES[*]:$start_right}"
        fi
    fi
}

# This set of variables are used when invoking 'eval "${update_srm}"'
# to repackage the SRMLINES array with processed data.
declare update_srm_IFS
declare update_srm_String
declare update_srm_line

# Build update_srm string from array of strings for easier reading
declare -a update_srm_cmds=(
    "update_srm_IFS=\${IFS};"                # save IFS
    "IFS=\$'\\n';"                           # set IFS to ignore all but newlines
    "SRMLINES=();"                           # clear previous SRMLINES
    "while read -s update_srm_line;"         # beginning of read statement
    "do SRMLINES+=( \"\$update_srm_line\" );"
    "done <<< \"\${update_srm_String}\";"
    "SRMLINES_COUNT=\"\${#SRMLINES[@]}\";"   # new SRMLINES_COUNT for in_range()
    "IFS=\"\${update_srm_IFS}\";"            # extra-careful clean up by restoring IFS
    )
declare update_srm=( "${update_srm_cmds[*]}" )

DO_sibling-before()
{
    local -i index="$1"
}

DO_sibling-after()
{
    local IFS=$'\n'
    local -i index="$1"
    local -i level last_line
    local res
    if level=$( srm_level "$index" ); then
        if last_line=$( find_branch_last_line "$index" ); then
            SRM_splice "$last_line" 0 "${@:2}"
            return 0
        fi
    fi

    return 1
}

DO_child_append()
{
    local -i index="$1"
}

get_available_actions()
{
    local RE_FUNCTION='[[:space:]]DO_(.*)$'
    local -a flist
    local func
    local IFS=$'\n'
    if flist=( $( declare -f -F ) ); then
        for func in "${flist[@]}"; do
            if [[ "$func" =~ $RE_FUNCTION ]]; then
                echo "${BASH_REMATCH[1]}"
            fi
        done
    fi
}

show_available_actions()
{
    local -a actions=( $( get_available_actions ) )
    echo "The actions currently available are:" >&2
    printf "   %s\n" "${actions[@]}" >&2
}

process_action()
{
    if [ -n "$P_LINE_INDEX" ]; then
        if [ -n "$P_ACTION" ]; then
            # Swallow the return value. We're only interested
            # in if the value exists or not.
            local -i index
            if index=$( find_in_array "$P_ACTION" "${DOActions[@]}" ); then
                "DO_$P_ACTION" "$P_LINE_INDEX" "${P_ARRAY[@]}"
                return "$?"
            else
                show_available_actions
            fi
        fi
    fi
    return 1
}

declare arg result
declare -i P_LINE_INDEX=-2
declare -f P_ACTION
declare -a P_ARRAY
declare -i P_FAILED_STATE

declare OIFS="$IFS"
IFS=$'\n'
declare -a DOActions=( $( get_available_actions ) )
IFS="${OIFS}"

declare -a clear_p_state_arr=(
    "P_LINE_INDEX=-2;"
    "P_ACTION=;"
    "P_ARRAY=;"
    "P_FAILED_STATE=0"
)

echo "clear_p_state_arr = '${clear_p_state_arr[*]}'" >&2

clear_p_state()
{
    P_LINE_INDEX=-2
    P_ACTION=
    P_ARRAY=
    P_FAILED_STATE=0
}

if [ "$1" = "--help" ]; then
    show_available_actions
    exit 0
fi

if read_srm_file "$1"; then
    for arg in "${@:2}"; do
        if [ "$P_FAILED_STATE" -ne 0 ]; then
            echo "FAILED STATE!" >&2
            # Discard parameters for this action, but allow
            # secondary commands if the terminating "--" is
            # found:
            if [ "$arg" = "--" ]; then
                eval "${clear_p_state_arr[*]}"
                # clear_p_state
            fi
        elif [ "$arg" = "--" ]; then
            if update_srm_String=$( process_action ); then
                eval $update_srm
            fi
            eval "${clear_p_state_arr[*]}"
        elif [ "$P_LINE_INDEX" -lt -1 ]; then
            if ! P_LINE_INDEX=$( find_branch "$arg" ); then
                P_FAILED_STATE=1
                echo "Failed to find path '$arg'" >&2
            fi
        elif [ -z "$P_ACTION" ]; then
            P_ACTION="$arg"
        else
            P_ARRAY+=( "$arg" )
        fi
    done

    # In case of missing "--", Catch any leftover status:
    if update_srm_String=$( process_action ); then
        eval $update_srm
    fi


    # When finished, write out all the
    # changes for study or saving:
    print_srm
else
    echo "Failed to open '$1'" >&2
fi



